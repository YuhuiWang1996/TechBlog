# JS 作用域 - ES5与ES6对比

- **相较于ES5，ES6新增了块级作用域**

## 全局作用域

- ==函数外部定义的都是全局变量==，全局变量有全局作用域
- **网页中所有脚本和函数均可使用**
	- ```var x = 123```
	- y = 1234
		- **注意** : 没有用var定义的变量是作为全局对象window的属性存在。
		- **验证** : 属性可以被删除，变量不能被删除。所以，可以执行delete window.y(delete y)，而不能执行delete x
		- 扩展 : **函数内部没有用var定义的变量也会挂载在window上**，作为window的属性
		- 总之，不要不加var，会造成语义不明，给window对象添加不必要的成员。

## 函数作用域

- ==函数内部定义的变量有函数作用域==，也称作局部作用域，只能在函数内部访问。
- 如果函数外部想要获取函数内部的值
	1. 可以直接return
	2. 也可以采用闭包的方法

		```js
		function fn() {
  		  const a = 1
  		  return function () {
    		    const b = 2
    		    return a + b + c;
  		  }
		}
		const a = 123;
		const b = 1234;
		const c = 3;
		const fn1 = fn();
		console.log(fn1()); // 6
		```

		- a，b，c会不断向上寻找，形成函数的**作用域链**
		
- 因为局部变量只作用于函数内，所以不同的函数可以使用相同名称的变量。
- 局部变量在函数开始执行时创建，函数执行完后局部变量会自动销毁。

## 块状作用域

- ==有{ }的地方就是一个块，有独立的作用域==
- 不能再使用var了，因为var会变量提升。
	- Let & Const 就不会有变量提升，会封闭在块中

## 动态作用域

- ==this与当前函数动态绑定的对象有关==，this是该动态绑定的对象

	```js
	window.a = 3
	function test () {
  	  console.log(this.a)
	}
	test() // 3
	test.bind({ a:100 })() // 100
	```

## let & const
	
- let声明的变量
	- 有块级作用域
	- 不能用全局对象的属性访问
	- 不能重复定义，与var不同
	- 不会进行变量提升

- const声明的变量
	- let有的特性const都有
	- const定义的时候常量，不允许修改
	- **const不允许先声明后赋值，let和var都可以**


